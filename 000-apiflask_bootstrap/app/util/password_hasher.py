import base64
import random
import string
import hashlib
import hmac

UNUSABLE_PASSWORD_PREFIX = '!'  # This will never be a valid encoded hash
# number of random chars to add after UNUSABLE_PASSWORD_PREFIX
UNUSABLE_PASSWORD_SUFFIX_LENGTH = 40


def get_random_string(length=8, number_only=False, string_only=False):
    if string_only:
        return ''.join(random.sample(string.ascii_letters, length))
    if number_only:
        return ''.join(random.sample(string.digits, length))
    return ''.join(random.sample(string.ascii_letters + string.digits, length))


def is_password_usable(encoded):
    """
    Return True if this password wasn't generated by
    User.set_unusable_password(), i.e. make_password(None).
    """
    return encoded is None or not encoded.startswith(UNUSABLE_PASSWORD_PREFIX)


def check_password(raw_password, hash_password):
    hasher = PBKDF2PasswordHasher()
    is_correct = hasher.verify(raw_password, hash_password)
    return is_correct


def make_password(password, salt=None):
    if password is None:
        return UNUSABLE_PASSWORD_PREFIX + get_random_string(UNUSABLE_PASSWORD_SUFFIX_LENGTH)
    hasher = PBKDF2PasswordHasher()
    salt = salt or hasher.salt()
    return hasher.encode(password, salt)


def pbkdf2(password, salt, iterations, dklen=0, digest=None):
    """Return the hash of password using pbkdf2."""
    if digest is None:
        digest = hashlib.sha256
    dklen = dklen or None
    password = password.encode('utf-8')
    salt = salt.encode('utf-8')
    return hashlib.pbkdf2_hmac(digest().name, password, salt, iterations, dklen)


def constant_time_compare(val1, val2):
    """Return True if the two strings are equal, False otherwise."""
    return hmac.compare_digest(val1.encode(), val2.encode())


class PBKDF2PasswordHasher(object):
    """
    Secure password hashing using the PBKDF2 algorithm (recommended)

    Configured to use PBKDF2 + HMAC + SHA256.
    The result is a 64 byte binary string.  Iterations may be changed
    safely but you must rename the algorithm if you change SHA256.
    """
    algorithm = "pbkdf2_sha256"
    iterations = 150000
    digest = hashlib.sha256

    def encode(self, password, salt, iterations=None):
        assert password is not None
        assert salt and '$' not in salt
        iterations = iterations or self.iterations
        hash = pbkdf2(password, salt, iterations, digest=self.digest)
        hash = base64.b64encode(hash).decode('ascii').strip()
        return "%s$%d$%s$%s" % (self.algorithm, iterations, salt, hash)

    def verify(self, password, encoded):
        algorithm, iterations, salt, hash = encoded.split('$', 3)
        assert algorithm == self.algorithm
        encoded_2 = self.encode(password, salt, int(iterations))
        return constant_time_compare(encoded, encoded_2)

    def salt(self):
        return get_random_string(length=12)
